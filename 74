
import java.util.*;
class Result {
  static int countPaths = 0;
  // Check if current cell (x, y) is safe to move
  static boolean isSafe(int[][] maze, int x, int y, int N) {
    return (x >= 0 && y >= 0 && x < N && y < N && maze[x][y] == 0);
  }
  // Recursive utility to explore all paths
  static void solveMazeUtil(int[][] maze, int x, int y, int N) {
    // If destination is reached
    if (x == N - 1 && y == N - 1) {
      countPaths++;
      return;
    }
    // Move Down
    if (isSafe(maze, x + 1, y, N))
      solveMazeUtil(maze, x + 1, y, N);
    // Move Right
    if (isSafe(maze, x, y + 1, N))
      solveMazeUtil(maze, x, y + 1, N);
  }
  // Main function
  public static int solveMaze(int[][] maze, int size) {
    countPaths = 0;
    // If start or destination is blocked, no path exists
    if (maze[0][0] == -1 || maze[size - 1][size - 1] == -1)
      return 0;
    solveMazeUtil(maze, 0, 0, size);
    return countPaths;
  }
  // Driver
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    int[][] maze = new int[N][N];
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        maze[i][j] = sc.nextInt();
      }
    }
    System.out.println(solveMaze(maze, N));
  }
}
