
class Result {
  static int jobScheduling(int[] deadlines, int[] profits) {
    int n = deadlines.length;
    if (n == 0) return 0;
    // Create Job class array to store deadline and profit together
    Job[] jobs = new Job[n];
    for (int i = 0; i < n; i++) {
      jobs[i] = new Job(deadlines[i], profits[i]);
    }
    // Sort jobs by profit in descending order (max profit first)
    Arrays.sort(jobs, (a, b) -> b.profit - a.profit);
    // Find the maximum deadline to know the maximum number of available slots
    int maxDeadline = 0;
    for (Job job : jobs) {
      maxDeadline = Math.max(maxDeadline, job.deadline);
    }
    // Create an array to track used time slots (1-based indexing)
    int[] slots = new int[maxDeadline + 1];
    Arrays.fill(slots, -1);
    int totalProfit = 0;
    // Try to schedule each job in the latest available slot before its deadline
    for (Job job : jobs) {
      for (int t = job.deadline; t > 0; t--) {
        if (slots[t] == -1) { // Slot available
          slots[t] = job.profit; // Schedule the job here
          totalProfit += job.profit;
          break;
        }
      }
    }
    return totalProfit;
  }
  // Helper class to represent a job
  static class Job {
    int deadline, profit;
    Job(int d, int p) {
      this.deadline = d;
      this.profit = p;
    }
  }
}
